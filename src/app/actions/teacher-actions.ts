\'use server\';\n\nimport { createServerActionClient } from \'@supabase/auth-helpers-nextjs\';\nimport { cookies } from \'next/headers\';\nimport Papa from \'papaparse\';\nimport { z } from \'zod\';\n\n// Define the expected structure of a row in the CSV file.\nconst CsvRowSchema = z.object({\n    question_text: z.string().min(5),\n    type: z.enum([\'multiple_choice\', \'open_answer\', \'true_false\']),\n    difficulty: z.preprocess(val => Number(val), z.number().min(0).max(10)),\n    // answers and correct_answer will be JSON strings in the CSV\n    answers: z.string().optional(), \n    correct_answer: z.string(),\n    explanation: z.string().optional()\n});\n\ninterface CsvUploadResult {\n    success: boolean;\n    message: string;\n    insertedCount?: number;\n    errors?: any[];\n}\n\n/**\n * Handles the upload of a CSV file containing quiz questions.\n * Parses the file, validates the data, and inserts it into the database.\n *\n * @param csvContent The raw string content of the CSV file.\n * @param subject_id The ID of the subject to associate these questions with.\n * @returns An object indicating the result of the operation.\n */\nexport async function handleCsvUpload(csvContent: string, subject_id: string): Promise<CsvUploadResult> {\n    const supabase = createServerActionClient({ cookies });\n\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n        return { success: false, message: \"Authentication required.\" };\n    }\n\n    try {\n        const parseResult = Papa.parse(csvContent, {\n            header: true,\n            skipEmptyLines: true,\n        });\n\n        if (parseResult.errors.length > 0) {\n            return { success: false, message: \"Failed to parse CSV file.\", errors: parseResult.errors };\n        }\n\n        const validationErrors: any[] = [];\n        const validatedQuestions = parseResult.data.map((row, index) => {\n            const result = CsvRowSchema.safeParse(row);\n            if (!result.success) {\n                validationErrors.push({ row: index + 2, errors: result.error.flatten() });\n                return null;\n            }\n\n            try {\n                return {\n                    subject_id,\n                    question_text: result.data.question_text,\n                    type: result.data.type,\n                    difficulty: result.data.difficulty,\n                    answers: result.data.answers ? JSON.parse(result.data.answers) : null,\n                    correct_answer: JSON.parse(result.data.correct_answer),\n                    metadata: { source: \'csv_upload\' },\n                    author_id: user.id\n                };\n            } catch (e) {\n                validationErrors.push({ row: index + 2, errors: { json_parsing: \"Invalid JSON in answers or correct_answer column.\" } });\n                return null;\n            }\n        }).filter(q => q !== null);\n\n        if (validationErrors.length > 0) {\n            return { success: false, message: \"CSV validation failed.\", errors: validationErrors };\n        }\n\n        if (validatedQuestions.length === 0) {\n            return { success: false, message: \"No valid questions found in the CSV.\" };\n        }\n\n        const { data, error } = await supabase.from(\'questions\').insert(validatedQuestions as any);\n\n        if (error) {\n            return { success: false, message: `Database error: ${error.message}` };\n        }\n\n        return { success: true, message: `Successfully inserted ${validatedQuestions.length} questions.`, insertedCount: validatedQuestions.length };\n\n    } catch (e: any) {\n        return { success: false, message: `An unexpected error occurred: ${e.message}` };\n    }\n}\n